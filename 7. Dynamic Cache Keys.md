# Динамические ключи для кэширования

## Проблема

Когда вы используете стандартный `CacheInterceptor` в NestJS, он по умолчанию использует URL запроса в качестве ключа для кэширования. Это может стать проблемой, если ваши запросы имеют одинаковые URL, но должны кэшироваться отдельно для разных пользователей.

Например, если у вас есть маршрут `/tasks`, который возвращает список задач текущего пользователя, стандартный `CacheInterceptor` создаст один и тот же ключ для всех пользователей, так как URL запроса одинаков. Это означает, что кэшированные данные одного пользователя могут быть перезаписаны данными другого пользователя.

## Решение

Чтобы решить эту проблему, вы можете создать свой собственный интерцептор для кэширования, который будет использовать динамические ключи. В этом ключе можно учитывать как URL запроса, так и идентификатор текущего пользователя.

Вот как можно реализовать такой интерцептор:

```typescript
// user-id-cache.interceptor.ts
import { CacheInterceptor } from "@nestjs/cache-manager";
import { ExecutionContext, Injectable } from "@nestjs/common";
import { Request } from "express";

@Injectable()
export class UserIdCacheInterceptor extends CacheInterceptor {
  protected trackBy(ctx: ExecutionContext) {
    const request = ctx.switchToHttp().getRequest<Request>();
    const userId = request.user.id; // Используем ID пользователя
    const url = request.url; // Получаем URL запроса

    // Формируем уникальный ключ для кэша
    return `${userId}:${url}`;
  }
}
```

Теперь ваш кеш будет правильно управляться с учетом как идентификатора пользователя, так и URL запроса, что позволяет избежать проблем с перезаписью данных между пользователями.

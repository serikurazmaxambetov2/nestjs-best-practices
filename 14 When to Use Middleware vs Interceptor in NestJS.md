# Когда использовать Middleware, а когда Interceptor в NestJS

## Введение

В NestJS вы можете обрабатывать запросы с помощью различных механизмов, таких как Middleware и Interceptors. Однако выбор между этими инструментами зависит от задачи, которую нужно решить. Понимание того, когда использовать Middleware, а когда Interceptor, может значительно улучшить архитектуру вашего приложения.

## Middleware

### Когда использовать:

- **Обработка запросов до маршрутизации**: Middleware полезны для выполнения задач до того, как запрос достигнет маршрута. Например, логирование запросов, проверка JWT токенов, или модификация объекта `request`.
- **Глобальная логика**: Если требуется применить общую логику ко всем запросам, как, например, установка заголовков CORS или проверка аутентификации, Middleware — это ваш выбор.

### Пример:

```typescript
import { Injectable, NestMiddleware } from "@nestjs/common";

@Injectable()
export class LoggerMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: Function) {
    console.log(`Request...`);
    next();
  }
}
```

### Преимущества:

- Простота в использовании и внедрении.
- Отлично подходит для общих задач, которые не требуют доступа к контексту маршрута или обработке ответа.

## Interceptors

### Когда использовать:

- **Трансформация и модификация ответов**: Interceptors позволяют перехватывать и изменять ответы до того, как они отправятся клиенту. Это полезно для форматирования данных или добавления метаданных.
- **Управление потоками данных**: Interceptors могут изменять и контролировать данные как на входе (до выполнения обработчика), так и на выходе (после выполнения обработчика).
- **Валидация данных или контроль доступа**: Можно использовать Interceptors для дополнительных проверок или логики, зависящей от маршрута.

### Пример:

```typescript
import {
  Injectable,
  NestInterceptor,
  ExecutionContext,
  CallHandler,
} from "@nestjs/common";
import { Observable } from "rxjs";
import { map } from "rxjs/operators";

@Injectable()
export class TransformInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    return next.handle().pipe(map((data) => ({ data })));
  }
}
```

### Преимущества:

- Гибкость и мощность в обработке и модификации как входящих, так и исходящих данных.
- Подходит для задач, где требуется глубокая интеграция с логикой маршрута или трансформация данных.

## Заключение

- Используйте **Middleware** для обработки запросов до маршрутизации и для выполнения общих задач, которые должны применяться ко всем запросам.
- Используйте **Interceptors** для работы с потоками данных, модификации ответов и выполнения задач, которые требуют доступа к контексту маршрута или логике выполнения.
